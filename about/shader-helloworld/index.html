<h1>Minimal WebGL program</h1><h2>Vertex shader</h2><pre><code class="language-glsl">precision highp float;
attribute vec4 position;

void main() {
  gl_Position = position;
}
</code></pre><h2>Fragment shader</h2><pre><code class="language-glsl">precision highp float;
uniform float time;
uniform vec2 resolution;

void main() {
  vec2 p = gl_FragCoord.xy / resolution - .5;
  float x = length(p) * 22. - time * 3.;
  gl_FragColor= vec4(sin(x), sin(x + 1.2), sin(x + 2.4), 1.);
}
</code></pre><h2>The JavaScript stuff</h2><h3>Initialize the WebGL context</h3><p>This part is quite similar to working with the canvas 2D API:</p><pre><code class="language-js">const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');
</code></pre><h3>Compile the shaders</h3><p>GLSL is a compiled language. WebGL provides APIs to compile and link the shader code:</p><pre><code class="language-js">/**
 * Compile Shader
 * @param {number} type gl.FRAGMENT_SHADER | gl.VERTEX_SHADER
 * @param {string} code shader code
 */
function shader = (type, code) =&gt; {
  const sh = g.createShader(type, code);
  g.shaderSource(sh, code);
  g.compileShader(sh);
  if (!g.getShaderParameter(sh, g.COMPILE_STATUS)) {
    throw g.getShaderInfoLog(sh);
  }
  return sh;
};
</code></pre><h3>Link the WebGL program</h3><pre><code class="language-js">const program = gl.createProgram();
gl.attachShader(program, shader(g.FRAGMENT_SHADER, vert));
gl.attachShader(program, shader(g.FRAGMENT_SHADER, frag));
gl.linkProgram(program);

if (!gl.getProgramParameter(p, g.LINK_STATUS)) {
  throw gl.getProgramInfoLog(p);
}

gl.useProgram(program);
</code></pre><h2>Setting up buffers and attributes</h2><pre><code class="language-js">const positionAttrib = g.getAttribLocation(p, 'position');
const positionBuffer = g.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(
  g.ARRAY_BUFFER,
  // 2D vertex data for two triangles filling up the whole screen
  new Float32Array([-1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1]),
  g.STATIC_DRAW
);

// bind position buffer to position attribute.
// Specify that the variable is a vec2 of floats.
gl.enableVertexAttribArray(pAL);
gl.bindBuffer(g.ARRAY_BUFFER, pB);
gl.vertexAttribPointer(pAL, 2, g.FLOAT, false, 0, 0);
</code></pre><h2>Setting up the viewport and add resize handler</h2><pre><code class="language-js">function setSize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  gl.viewport(0, 0, innerWidth, innerHeight);
  const locResolution = gl.getUniformLocation(p, 'resolution');
  gl.uniform2fv(locResolution, [innerWidth, innerHeight]);
}

setSize();
window.addEventListener('resize', setSize, false);
</code></pre><h2>Render loop</h2><pre><code class="language-js">/**
 * Render loop
 */
function loop(time = 0) {
  const locTime = g.getUniformLocation(p, 'time');
  g.uniform1f(locTime, time * 1e-3);
  // draw 6 vertices (=two triangles)
  g.drawArrays(g.TRIANGLES, 0, 6);
  requestAnimationFrame(loop);
}
</code></pre><h3>Putting it all together:</h3><p><a href="https://codepen.io/terabaud/pen/MWeeqaX?editors=0010">Try on CodePen</a></p>